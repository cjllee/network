SSL(Secure Socket Layer)은 SSL 1.0부터 시작해서 SSL 2.0, SSL 3.0,
TLS(TransportLayer Security Protocol) 1.0, TLS 1.3까지 버전이 올라가며 마지막으로
TLS로 명칭이 변경되었습니다. 여기서는 TLS 1.3을 기반으로 설명합니다.
TLS은 전송 계층에서 보안을 제공하는 프로토콜입니다. 클라이언트와 서버가 통신 할 때
TLS를 통해 제3자가 메시지를 도청하거나 변조하지 못하도록 합니다
![](https://velog.velcdn.com/images/cjllee/post/9bc76fb4-035a-4672-9cec-ded78ab2d162/image.png)
사용할 TLS버전을 정하고, 사이퍼슈트, 서버의 공개키, SSL인증서를 기반으로 인증작업을
수행합니다. 이 후 대칭 암호화를 위해 세션키를 생성합니다.
### 1. Client Hello
클라이언트는 TLS버전, 사이퍼슈트와 클라이언트 랜덤값(무작위 문자열), 임시 DH
매개변수를 서버에게 보냅니다.
### 2. Server Hello, EncryptedExtensions, Certificate, CertificateVerify
서버는 클라이언트로부터 받은 옵션을 확인합니다. 서버와 클라이언트 모두에서 지원하는
가장 높은 TLS 버전을 식별하며 결정, 사이퍼슈트 지원 여부를 확인합니다. 공개키가 포함된
SSL 인증서, 서버 랜덤값, 임시 DH 매개변수를 보냅니다. 그리고 클라이언트와 서버 각각
서로 교환한 DH 매개변수를 사용하여 임시 암호 키(세션키)를 생성합니다.
### 3. Finished
클라이언트와 서버와 세션키를 기반으로 대칭 암호화된 통신이 시작됩니다.(보안세션이
시작되었다고도 말합니다.)
키교환 알고리즘으로는 대표적으로 RSA와 DH가 있습니다. 여기서는 DH를 기반으로
설명합니다. TLS1.3버전에서는 RSA 같은 경우 취약점이 있기 때문에 공식적으로 지원하지
않습니다. DH의 경우 타원곡선 DH를 사용합니다

## DH 매개변수
DH는 Diffie-Hellman을 의미합니다. Diffie-Hellman 알고리즘은 서로 공개값 공유,
비밀값과 혼합, 혼합값과 공유, 각자의 비밀값과 혼합해서 공통의 암호키를 만드는
알고리즘입니다.
![](https://velog.velcdn.com/images/cjllee/post/efc27d04-609b-47a4-8210-593496e7aec1/image.png)
DH는 그냥 디피헬만을 사용하는 DHE와 타원곡선암호화 방법과 DH를 섞은 ECDHE가
있고 보통 ECDHE를 씁니다.
![](https://velog.velcdn.com/images/cjllee/post/a3df2718-ecfb-41b0-9eff-791a30b15258/image.png)
타원곡선 암호화 방법이란 곡선을 사용하여 개인 키 보유자만 알 수 있는 타원곡선을
그립니다. 이걸 기반으로 교차점을 생성합니다. 이 교차점의 수를 기반으로 암호를 설정하는 방법을 말합니다

## 사이퍼슈트
사이퍼 슈트는 프로토콜, AEAD 사이퍼 모드, 해싱 알고리즘이 나열된 규약을 말하며
암호제품군이라고도 불립니다. TLS1.3버전에는 다섯 개가 있습니다.
• TLS_AES_128_GCM_SHA256
• TLS_AES_256_GCM_SHA384
• TLS_CHACHA20_POLY1305_SHA256
• TLS_AES_128_CCM_SHA256
• TLS_AES_128_CCM_8_SHA256

## 해싱 알고리즘
해싱 알고리즘은 데이터를 추정하기 힘든 더 작고, 섞여 있는 조각으로 만드는
알고리즘입니다. SSL/TLS는 해싱 알고리즘으로 SHA-256 알고리즘과 SHA-384
알고리즘을 쓰는데, 그 중 많이 쓰는 SHA-256 알고리즘을 설명하겠습니다. SHA-256
알고리즘은 해시 함수의 결괏값이 256비트인 알고리즘이며 비트 코인을 비롯한 많은
블록체인 시스템에서도 씁니다.

![](https://velog.velcdn.com/images/cjllee/post/ba3ea31b-d62e-4b6f-81ea-f0fbe98899d8/image.png)

## 인증서
인증서는 1. 주체(인증서 발급한 CA, 도메인, 웹사이트 소유자, 인증서 소유자), 2.
공개키(공개키, 공개키암호화방법)를 포함하는 단순한 데이터 파일입니다. 자신의 웹사이트
안에서 SSL 인증서를 만들 수도 있지만 보통은 인증기관인 CA에서 발급한 SSL인증서를
기반으로 인증작업을 수행합니다.
주체는 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지 확인할 때 쓰이고
공개키는 처음 인증작업을 수행할 때쓰입니다.

## CA
인증서의 역할은 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지를
보장하는 역할을 합니다. 이 인증서를 발급하는 기업들을 CA(Certificate Authority)라고
합니다. 참고로 서비스의 도메인, 공개키와 같은 정보는 서비스가 CA로부터 인증서를 구입할
때 제출해야 합니다. 인증서는 다양한 유형의 인증서가 있습니다.

![](https://velog.velcdn.com/images/cjllee/post/7b8974ca-d23f-4196-b552-c0b80bc51a6d/image.png)

- 단일 도메인: 단 하나의 도메인(www.naver.com)에 적용되는 인증서
- 와일드카드: 도메인의 하위 도메인도 포함하는 인증서. 예를 들어
www.cloudflare.com, blog.cloudflare.com
- 멀티 도메인: 이름이 의미하는 것처럼 멀티 도메인 SSL 인증서는 관련되지 않은
다수의 도메인에 적용될 수 있는 인증서

## RSA의 취약점
RSA의 경우 클라이언트가 생성한 임시 암호값을 서버로 전송하지만 DH의 경우
클라이언트와 서버가 서로 교환한 DH 매개변수를 사용해 개인키를 만듭니다. 이 때문에
RSA는 클라이언트에서 생성한 임시 암호값이 탈취당한 경우 해킹의 위험이 있습니다. 그러나
DH의 경우 탈취당해도 공통의 암호키를 못 만들기 때문에 더 좋은 것입니다.

## 0 - RTT
세션키가 생성된 이 후 다시 그 사이트에 방문한다면 미리 만들어 놓은 세션키(PSK,
pre-shared key)를 기반으로 연결을 생성하기 때문에 이 때 인증에 드는 비용은 없습니다.
즉, 인증에 관한 RTT가 발생되지 않기 때문에 0- RTT 라는 특징을 갖습니다.
