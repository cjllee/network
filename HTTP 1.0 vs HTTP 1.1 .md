## HTTP/1.0
HTTP/1.0은 수명이 짧은 연결이라고 합니다. HTTP요청은 자체 요청에서 완료가 됩니다. 각 HTTP 요청당 TCP 핸드셰이크가 발생되며 기본적으로 한 연결당 하나의 요청을 처리하도록 설계되었습니다.한번 연결할 때마다 TCP연결을 계속해야 하니 RTT가 늘어나는 문제점이 있었습니다.

![](https://velog.velcdn.com/images/cjllee/post/f11d584e-872a-44e2-a72f-7257045355f4/image.png)

## HTTP/1.1
HTTP/1.1은 HTTP/1.0의 단점을 보완한 프로토콜입니다. 크게 3가지의 차이점이 있습니다.
### 1.keep-alive default
매번 데이터를 요청할 때마다 TCP 연결을 하는게 아닌 한번 해놓고 계속해서 데이터를 받을 수 있게 만들었습니다. 이는 keep-alive 옵션을 기본옵션으로 하면서 가능해졌습니다.

### 2. 호스트 헤더
HTTP/1.0은 서버가 하나의 호스트만 가진다고 가정하기 때문에 HTTP/1.0은 헤더에
호스트를 포함하지 않았습니다. 이 때문에 HTTP/1.0은 하나의 IP에 하나의 호스트만 가질 수 있었습니다.
그러나 사실 서버는 여러개의 호스트를 가질 수 있으며 이런 유연성을 위해 HTTP/1.1은
헤더에 특정 호스트를 포함할 수 있게 변경되었으며 항상 호스트를 포함해서 요청하도록
바뀌었습니다.


### 3. 대역폭 최적
HTTP/1.0의 경우 어떠한 파일을 다운로드 받다가 연결이 끊기면 다시 다운로드 받는 것은 불가능했습니다. 이를 다시 다운로드 받을 수 있게 바뀌었습니다.
예를 들어 HTTP/1.0에서는 10KB 파일을 다운로드 받는다고 했을 때 5KB까지만 받고 다시 다운로드를 받는게 불가능했습니다. 이를 HTTP/1.1에서는 Range:bytes=5000- 라는 헤더를 추가해서 다운로드 재개 요청을 할 수 있게 바뀐 것입니다.

## 요청을 줄이기 위한 기술
HTTP/1.1로 발전했음에도 불구하고 서버요청할 때마다 RTT는 계속해서 증가하기 때문에
요청을 줄이기 위한 여러가지 기술들이 있었습니다. 대표적으로 이미지스프라이트(image sprite), 코드압축, Base64 인코딩 기술을 같이 쓰게 되었습니다. 참고로 HTTP 버전이 올라간 뒤에도 이러한 기술들을 같이 쓰곤 합니다.


### 이미지 스프라이트
수많은 이미지를 하나의 이미지로 만들어 하나의 이미지만 다운받아놓고 이를 통해 수많은 이미지를 다운받는 듯한 효과를 내는 것을 말합니다.

### 코드압축
코드를 압축해서 서빙합니다.

### 이미지 Base64 인코딩
이미지 파일을 64진법으로 이루어진 문자열로 인코딩해서 이미지 서버에 대한 HTTP 요청을 할 필요가 없이 만드는 것을 말합니다. 하지만 Base64 인코딩을 할 경우 파일크기가
37퍼센트 크기가 더 커지는 단점이 있었습니다.

## HTTP/1.1의 고질적인 문제 : HOL
그러나 HOL과 무거운 헤더(Header)를 가지는 문제점이 있었고 이를 해결하지 못했습니다. HOL(Head Of Line Blocking) 네트워크에서 같은 큐에 있는 패킷이 그 첫번째 패킷에 의해 지연될 때 발생하는 성능저하현상을 말합니다.
